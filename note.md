# 设计模式学习笔记 #

## 前言
在软件开发上，只有“变化”才是永恒不变的真理。

设计模式的主要意义，在于应对后续需求的“变化”及代码维护工作。


## UML图
图参考纸质笔记
软件工程图例.pptx

### 类之间的关系
根据类与类之间的耦合度**从弱到强**排列，UML 中的类图有以下几种关系：

- 依赖关系
- 关联关系
- 聚合关系
- 组合关系
- 继承关系 
- 实现关系
其中继承和实现的耦合度相等，它们是最强的。

1. 依赖关系
是指在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法或属性。在 UML 类图中，依赖关系使用带箭头的虚线来表示，箭头从**使用类**指向**被依赖的类**。

代码中实现:
- 依赖类A的方法使用被依赖类B对象作为入参和出参。
- 依赖类A的方法使用被依赖类B对象作为局部变量。
- 依赖类A的方法调用被依赖类B的方法，包括成员方法和静态方法。

可概括为方法中使用被依赖类

2. 关联关系
双向的关联可以用带两个箭头或者没有箭头的实线来表示，单向的关联用带一个箭头的实线来表示.

箭头从关联类指向被关联的类。has-a

代码中实现关联关系：
- 关联类A中声明了一个被关联类B类型的属性
- 关联类A中使用了被关联类B的全局变量

可概括为属性中使用被依赖类

3. 聚合关系
是一种强关联关系，是整体和部分之间的关系，是 has-a 的关系。

聚合关系也是通过成员对象来实现的。成员类的对象作为整体类的数据字段，成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如 航母编队 -> 核动力潜艇，计算机 -> cpu

在 UML 类图中，聚合关系用带空心菱形的实线来表示，菱形指向整体。

表现在代码层面，和关联关系是一致的，只能从语义级别来区分

4. 组合关系
表示类之间的整体与部分的关系，是一种更强烈的聚合关系，是 has-a / contains-a 关系。

在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。例如人 -> 大脑

在 UML 类图中，组合关系用带实心菱形的实线来表示，菱形指向整体。

表现在代码层面，和关联关系是一致的，只能从语义级别来区分。

5. 继承关系
继承关系是对象之间耦合度最大的一种关系，是父类\子类之间的关系，是 is-a 的关系。在 UML 类图中，继承关系用带空心三角箭头的实线来表示，箭头从子类指向父类。在代码实现时，使用面向对象的继承机制来实现。

6. 实现关系
耦合度最大的一种关系，是接口\实现类之间的关系，是 is-a 的关系。在 UML 类图中，实现关系用带空心三角箭头的虚线来表示，箭头从实现类指向接口。在代码实现时，使用接口机制来实现。

has-a关系的强弱程度：组合 > 聚合 > 关联 > 依赖

### has-a 和 is-a

1. has-a
```
type Phone struct {
   type string
}

type Iphone struct {
   phone Phone
   number String
}
```

2. is-a
```
type Phone struct {
   type string
}

type Iphone struct {
   Phone
   num String
}
```


## 软件工程7条原则
1. 开闭原则 
   对扩展开放，对修改封闭

   - 面对需求变化时，对程序的改动是通过新增的代码实现的，而不是改变存量代码。保持存量代码的稳定性。
   - 无论模块多么封闭，都存在一些无法封闭的变化。设计人员应该预测出最有可能变化的模块，然后构造抽象来隔离这些模块
   - 一旦变化发生立即采取行动。若最初编写时未预测到变化，当变化发生时，一旦发生变化时，立即创建抽象来隔离以后发生的同类变化。
   - 过度抽象。对于程序中每个部分都进行刻意抽象，不是一个好主意。拒绝不成熟的抽象和抽象本身同样重要。

2. 里氏替换原则  
   子类必须能够替换掉他们的父类。
   子类可以扩展父类的功能，但不能改变父类原有的功能。如果子类必须修改父类的方法，为了不违背里氏替换原则，其修正方法是：取消原来的继承关系，重新设计它们之间的关系。
   子类必须完全实现父类的方法；子类可以有自己的个性；
   子类覆盖或实现父类方法时，子类输入参数类型范围应大于等于父类，子类返回参数类型范围应小于等于父类。

   
3. 依赖倒置原则
   高层模块不应该依赖低层模块。不可分割的原子逻辑即低层模块，原子逻辑的组合即高层模块。
   抽象不应该依赖细节，细节应该依赖抽象。

   依赖倒置原则的目的是通过要**面向接口编程**来降低类间的耦合性，所以我们在实际编程中只要遵循以下4点，就能在项目中满足这个规则。
   - 每个类尽量提供接口或抽象类，或者两者都具备。
   - 变量的声明类型尽量是接口或者是抽象类。
   - 任何类都不应该从具体类派生。具体类之间不发生直接的依赖关系。
   - 使用继承时尽量遵循里氏替换原则。
  
4. 单一职责原则
   一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分。

   - 能够保持类的稳定性和可靠性

5. 接口隔离原则
   一个类对另一个类的依赖应该建立在最小的接口上

6. 迪米特法则
   Talk only to your immediate friends and not to strangers。
   如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。
   
   - 在类的结构设计上，每个类应该降低类成员的访问权限
   - 强度类之间的松耦合。类之间耦合越弱，越有利于复用和修改。
   - 过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低。


7. 合成复用原则
   在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。如果要使用继承关系，则必须严格遵循里氏替换原则


## 23种设计模式分类
1. 根据目的来分
- 创建型模式：用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF 中提供了单例、原型(模板)、工厂方法、抽象工厂、建造者等 5 种创建型模式。

- 结构型模式：用于描述如何将类或对象按某种布局组成更大的结构，GoF 中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。

- 行为型模式：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。GoF 中提供了模板方法、策略、命令、责任链、状态、观察者（发布-订阅）、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。

2. 根据作用范围来分

- 类模式：用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。GoF中的工厂方法模式、（类）适配器模式、模板方法模式、解释器模式属于该模式。
  
- 对象模式：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。GoF 中除了以上 4 种，其他的都是对象模式。

观察者模式 <=> 发布-订阅模式

3. 常用设计模式
单例、工厂、模板方法、适配器、装饰、策略、代理组合、责任链、观察者

## 设计模式的作用
设计模式要干的事情就是解耦，达到高内聚低耦合。
创建型模式是将原本同一个类中，对象创建和对象使用的代码解耦，拆分成不同的类。
结构型模式是将原本同一个类中，负责不同功能的代码解耦，拆分到不同的类。
行为型模式是将不同的行为代码解耦。

## 单例模式
创建型

### pros
- 减少内存开销，特别是一个对象需要频繁创建 / 销毁时
- 减少系统性能开销， 特别是一个对象创建时需要较多资源，如读取配置、产生其它依赖对象
- 避免对资源多重占用，如避免对一个文件同时写操作
- 设置全局的访问点，优化共享资源访问

### cons
- 扩展困难。一般没有接口，不会被继承，要扩展只能修改代码
- 测试困难。无法Mock单例模式对象。并行测试环境，如果单例模式没有完成，不能进行测试
- 违反单一职责原则。一个类除了实现业务逻辑外，还要考虑这个类必须“是单例的”，因此把业务逻辑和“是单例的”融合在一个类中。

### applications
要求系统中某类型有且仅有一个对象时使用，例如：
- 要求生成唯一序列号
- 共享访问点或共享数据，如全局计数器
- 创建一个对象时会消耗过多的资源，如磁盘IO、网络IO、数据库
- 定义大量的静态常量和静态方法，如工具类

## 工厂模式
创建型

### pros
- 良好的封装性，调用者不用关心
  
- 降低高层模块和低层模块的耦合。
- 使产品类透明化。用户不用
- 优秀的扩展性，符合开闭原则。

### cons
- 增加代码的复杂度

## 中介模式

### pros
降低类间依赖，把一对多的依赖变成一对一的依赖

### cons
中介对象会膨胀得很大，逻辑复杂

### application
- 适用于多个对象之间紧密耦合的情况。紧密耦合的标准是：类图中出现了蜘蛛网状结构
- 适用于N个对象间产生了相互依赖的关系（N >２）
- 适用于多个对象有依赖关系，且依赖关系尚不确定，或者容易发生改变（需求变化频繁）

## 桥接模式
结构型

抽象类和实现类解耦，抽象类和实现类可以独立变化。
一个类有两个独立变化的维度，可以用桥接模式重构

## 适配器模式
结构型

将不兼容的接口转为可兼容的接口，让原本由于接口不兼容而不能一起工作的两个类，能够一起工作
应用场景：接口不兼容

- 类适配器
- 对象适配器

## 享元模式
结构型

- 意图是复用对象，节约内存
- 前提为不可变对象
- 可以将一般类拆分成易变类（外部状态类）和不可变类（内部状态类）

## 观察者模式
行为型

同步阻塞是最经典的实现方式，主要是为了代码解耦；
异步非阻塞除了能实现代码解耦之外，还能提高代码的执行效率；
进程间的观察者模式解耦更加彻底，一般是基于消息队列来实现，用来实现不同进程间的被观察者和观察者之间的交互。

TODO: EventBus

## 迭代器模式
行为型

用于遍历对象。迭代器模式将结合对象的遍历操作从集合类中解耦，放到迭代器类中，让两者的职责更加单一

## 访问者模式
行为型

需要遍历一组不同类型的对象，并且所有对象继承相同的父类或接口。
Go中使用类型断言来替代方法重载
Go语言只有重写没有重载

## 状态模式
行为型

用于实现状态机

- 有限状态机 FSM
组成：状态、事件（转移条件）、动作（状态触发执行的动作，非必须）
实现：
1. 分支逻辑法：状态和逻辑较少时使用，大量if/else。
2. 查表法：状态很多，转移逻辑很复杂。
3. 状态模式：状态不多、转移逻辑简单，但是动作比较复杂时，优先选择。

## 责任链
行为型

有链表式，数组式

### 选项模式
golang 特有设计模式

为了实现选项，增加了很多的代码，实现成本相对还是较高的，所以实践中需要根据自己的业务场景去权衡是否需要使用
满足下面条件可以考虑使用选项模式：

- 参数确实比较复杂，影响调用方使用
- 参数确实有比较清晰明确的默认值
- 为参数的后续拓展考虑
